
メモ


## まず解ける状態にしよう

とりあえずB問題を実装して、スコア計算できるようにする。


一種類のスコアの下がり幅は、cの累乗で増えていく。規則的。
次にどれくらい下がるか？が重要そう。2回以上前のスコアの推移状況は気にしなくていいんじゃないかな。

一旦、適当に、日数 % 26 でコンテストを開催するような適当なコードで提出。ほぼランダムみたいなもの。

score : 13639
- https://atcoder.jp/contests/intro-heuristics/submissions/42064332

次回以降は、これを超えればとりあえずOKでしょう。

手元でベンチスコア取れるようにテストコード作った方がいいね。


## その日に得られるスコアが一番大きいコンテストを選ぶ

`s[d]` のうち、一番スコアが高いものを使うようにする。

状態持たなくていいので、一旦先にこれ実装する。

ただ、これは本当はよくないはず。その日に開催して一番スコアが増えそうなものをGreedyにやるほうがいいはず。


実装してみたら出力がAのサンプルのものと一緒になった。なるほど


score : 0
- [提出 #42064472 - Introduction to Heuristics Contest](https://atcoder.jp/contests/intro-heuristics/submissions/42064472)

スコア0？

```
D 日目の終了時点での満足度をS とすると、
max(10^6 +S,0)
```

の存在を忘れていた。スコア計算用の処理に入れておこう。
