
メモ


## まず解ける状態にしよう

とりあえずB問題を実装して、スコア計算できるようにする。


一種類のスコアの下がり幅は、cの累乗で増えていく。規則的。
次にどれくらい下がるか？が重要そう。2回以上前のスコアの推移状況は気にしなくていいんじゃないかな。

一旦、適当に、日数 % 26 でコンテストを開催するような適当なコードで提出。ほぼランダムみたいなもの。

score : 13639
- https://atcoder.jp/contests/intro-heuristics/submissions/42064332

次回以降は、これを超えればとりあえずOKでしょう。

手元でベンチスコア取れるようにテストコード作った方がいいね。


## その日に得られるスコアが一番大きいコンテストを選ぶ

`s[d]` のうち、一番スコアが高いものを使うようにする。

状態持たなくていいので、一旦先にこれ実装する。

ただ、これは本当はよくないはず。その日に開催して一番スコアが増えそうなものをGreedyにやるほうがいいはず。


実装してみたら出力がAのサンプルのものと一緒になった。なるほど


score : 0
- [提出 #42064472 - Introduction to Heuristics Contest](https://atcoder.jp/contests/intro-heuristics/submissions/42064472)

スコア0？

```
D 日目の終了時点での満足度をS とすると、
max(10^6 +S,0)
```

の存在を忘れていた。スコア計算用の処理に入れておこう。

行き当たりばったりでやるのだとスコアが伸びない？ということがわかった？ほんと？


## その日の状態だけ見てGreedyにやってみる

その日に下がるスコアの量は、どのコンテストが最後にいつ開かれたかを覚えておけば計算できる。 その日に下がるスコアが一番少なくなるように = 一番スコアが増えるようにコンテスト種別を選ぶようにしてみる。

なので毎日その場で、 26通り を計算するようにしてみよう。

その日の最善を尽くす、という意味でGreedyかな？

score : 62730390
- [提出 #42079599 - Introduction to Heuristics Contest](https://atcoder.jp/contests/intro-heuristics/submissions/42079599)

スコアがかなり上がった。

類似でできることとしたら、2日先までみてみるとかかな？ (係数cの差によって、今日開催しなかったら明日もっと下がる！みたいなことがありえるので。)

365 x 26 x 26 なので計算は間に合うと思う。
